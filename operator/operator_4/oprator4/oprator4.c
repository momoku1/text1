#define   _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//续oprator3操作符
//
//int main()
//{
//	char a = -10;
//	//11110110
//	//整型提升结果：11111111111111111111111111110110
//	                            //1001
//
//	char b = 1;
//	//00000001
//	//整型提升结果：00000000000000000000000000000001
//
//	char c = a + b;
//	printf("c=%d", c);
//	return 0;
//}

//整型提升实例1：
/**/
//int main()
//{
//	char a = 0xb6;//char -128 ~127
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)//在判断是否相等时发生了整型提升
//		printf("a");
//	if (b == 0xb600)//同理
//		printf("b");
//	if (c == 0xb6000000)//本身就是整型
//		printf("c");
//	//所以结果输出c
//
//	return 0;
//}
//%u打印无符号整数
//%d打印有符号
//sizeof（）返回的是无符号整数
//实例2：
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));//1
//	printf("%u\n", sizeof(+c));//4
//	printf("%u\n", sizeof(-c));//4  此处进行的类型属性，值属性只是推测并没有算出最终值
//	//后两种发生了整型提升
         
//	return 0;
//}
//总结发生整型提升的只有：char 和 short

//任何一个表达式都有两个属性 ：值属性 、类型属性


//2.算数转换
/*说明：如果某个操作数的各个操作数属于不同的类型，那么除非其中一个操作数转换
为另一个操作数的类型，否则操作无法进行。下面的层次体系称为寻常算数转换
                                       32位
long  double//12
double //8
float//4
unsigned long int//8
long int //8
unsigned int //4
int//4
*/
//转换规则：1.向字节多的转换 2.字节相同向精度高的转换
//int main()
//{
//	int a = 10;
//	float b = 3.14;
//
//	printf("%u\n", sizeof(a + b));
//	return 0;
//}

//操作符的属性
/*
复杂表达式的求值有三个影响因素
1.操作符的优先级
2.操作符的结合性
3.是否控制求值顺序 :只有部分操作符，包含：&&（逻辑与），||（逻辑或）,？:（条件操作符），，（逗号操作符）
例：
a+b&&c+d
如果a+b为0那么c+d的值就无关了，即不会计算
*/
//int main()
//{
//	int a = 4;
//	int b = 5;
//	//int c=a+b*7;//优先级决定了计算顺序
//
//	int c = a + b + 7;//优先级不起作用，结合性决定了顺序
//	//
//	return 0;
//}
/*总结：
1.整型提升
2.算数转换
3.操作符的属性：
（1）.优先级
（2）.结合顺序
（3）.是否控制求值顺序
*/


//问题表达式：无法被控制产生出计算结果的表达式
//例1：
//a*b+c*d+e*f   假设a,b,c,d都为表达式
//通过优先级只能第二个*的计算比以一个+早，但是优先级并不能决定第三个*比第一个早
//因为优先级仅仅只能决定相邻的两个操作符谁先执行
//例2：
//c+--c    假设前一个c先准备好 结果为3 。假设前一个c在--c结束后准备好，结果为4
//所以矛盾了
//例3：取自c和指针
//int i=10;
//i=i-- - --i*(i=-3)*i++ + ++i;  其1问题:i--和i++并不相邻，不能确定谁先计算，且谁先准备好
//例4：
//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//int main()
//{
//	int answer=0;
//	answer = fun() - fun()*fun();//无法确定谁先调用
//	printf("%d\n", answer);
//	return 0;
//}
//
//例5：
//int main()
//{
//	int i = 1;
//	int ret = (++i) + (++i) + (++i);
//	printf("%d\n", ret);
//	return 0;
//}
//总结：我们写的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的



