#define   _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//指针初阶
/*
1.指针是什么
答：在计算机科学中，指针是编程语言中的一个对象，利用地址，他直接指向存在电脑存储
器中的另一个地方的值。由于 通过地址能找到所需的变量单元，可以说，地址指向该变量单元。
因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。
内存编号也是地址
2.指针和指针类型
//指针类型的意义：
//(1).指针类型决定了:指针解引用的权限有多大   。
//(2).指针类型决定了，指针走一步,能走多长（步长）。
3.野指针
概念：野指针就是指针所指向的位置是不可知的（随机的、不正确的、没有明确限制的）

4.指针运算
（1）.指针+-整数
（2）.指针-指针
（3）.指针的关系运算

5.指针和数组


6.二级指针
概念：指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？这就是二级指针

7.指针数组
*/
//int main()
//{
//	int a = 10;//占4个字节
//	int *p=&a;//拿到的是a的4个字节的首地址
//	*p= 20;
//	return 0;
//}

//int main()
//{
//	int* pa;
//	char* pc;
//	float* pf;
//
//
//	printf("%d\n", sizeof(pa));//4
//	printf("%d\n", sizeof(pc));//4
//	printf("%d\n", sizeof(pf));//4
//
//	return 0;
//}
//解引用权限实例：
//int main()
//{
//	
//	int a = 0x11223344;
//	char* pc = &a;
//	*pc = 0;//解引用访问1个字节
//	/*int* pa = &a;
//	*pa = 0;*//解引用访问4个字节
//	return 0;
//}

//指针类型决定了，指针走一步, 能走多长（步长）。
//相关实例
//int main()
//{
//	int arr[10] = { 0 };
//	int *p = arr;
//	char *pc = arr;
//	printf("p=%p\n", p);
//	printf("p+1=%p\n", p + 1);//加了4，地址加4相当于跳过了4个字符
//	//即跳过了一个整型
//	printf("pc=%p\n", pc);
//	printf("pc+1=%p\n", pc+ 1);//加了1，相当于跳过了一个字符
//	//即跳过了一个字符型
//	return 0;
//}


//int main()
//{
//	int arr[10] = { 0 };
//	//int *p = arr;
//	char *p = arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		*(p + i) = 1;//下标为i的地址
//	}
//	return 0;
//}

//野指针实例：
//1.指针未初始化
//int main()
//{
//	int *p;//p是一个局部变量，局部变量不初始化，默认是随机值。
//	*p = 10;//解引用时访问的随机值对应内存不属于当前程序，称为非法访问。即不是申请得到的内存
//
//	return 0;
//}

//2.指针越界访问
//int main()
//{
//	int arr[10] = { 0 };
//	int *p = arr;
//	int i = 0;
//	for (i = 0; i <= 10; i++)//访问地址超出了数组的长度
//	{
//		*p = i;
//		p++;//访问到的地址到+10的时候已经超出数组的地址范围，此时访问也是非法访问（越界访问）。
//		//printf("%d ", arr[i]);
//	}
//	return 0;
//}

//3.指针指向的空间释放了
//具体说明：指针指向的地址开始的确是申请而来的空间，但是后来释放了，此时访问就是非法访问。
//实例：
//int* test()
//{
//	int a = 10;
//	return &a;
//}
//int main()
//{
//	int *p = test();//函数结束的时候，局部变量a申请的内存已经被释放了
//	*p = 20;//此时访问就是非法访问内存
//	return 0;
//}

//总结：如何规避野指针？
//1.指针初始化     注意： (1).当前不知道p应该初始化为什么地址的时候，直接初始化为NULL
//int *p=NULL;    NULL包含在stdio.h中 要么是数值0 要么是地址0
//2.小心指针越界
//注意：c语言本身不会检查数组的越界行为
//3.指针指向空间释放，即时置NULL
//4.指针使用之前检查有效性
//
//int main()
//{
//	int* p = NULL;
//	if(p!=NULL)//判断是否为空指针，即为检查有效性
//       *p = 10;//
//	return 0;
//}


//#define N_VALUES 5
//int main()
//{
//	float values[N_VALUES];
//	float *vp;
//	//
//	for (vp = &values[0]; vp < &values[N_VALUES];)//指针的关系运算
//	{
//		*vp++ = 0;  //后置++,先解引用vp然后，vp++//指针的+-整数运算
//	}
//	return 0;
//}
//指针的关系运算以及指针加减整数
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int *p = arr;
//	int *pend = arr + 9;
//	while (p <= pend)
//	{
//		printf("%d\n", *p);
//		p++;
//	}
//	return 0;
//}


//指针-指针   得到的是两个指针之间元素的个数   
//使用前提：两个指针必须是指向的同一块空间
//指针+指针并没有意义
//例：
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	char c[5] = {0};
//	//printf("%d\n", &arr[9] - &arr[0]);//结果为9
//	printf("%d\n", &arr[9] - &c[0]);//错误
//
//	return 0;
//}


//练习
//#include <string.h>

//int my_strlen(char *p)
//{
//	int i = 0;
//	while (*p++ != '\0')
//	{
//		i++;
//	}
//	return i;
//}//计数器的写法

//int my_strlen(char *p)
//{
//	static int i = 0;
//	if (*p == '\0')
//	{
//		return 0;
//	}
//	else return my_strlen(p + 1) + 1;
//}//递归的写法
 
//int my_strlen(char* p)
//{
//	char* start = p;
//	while (*p != '\0')
//	{
//		p++;
//	}
//	return  p-start;//指针相减就等于两指针之间的元素个数
//}//指针-指针的写法
//
//
//int main()
//{
//	//strlen();-求字符串长度
//	//
//	char arr[] = "abc";
//	int len = my_strlen("abc");
//	printf("%d\n", len);
//
//	return 0;
//}

//指针的关系运算
//例：
//#define N_VALUES 10
//int main()
//{
//	int values[N_VALUES] = { 1,2,3,4,5,6,7,8,9,10};
//	int *vp;
//	/*for (vp = &values[N_VALUES]; vp > &values[0];)
//	{
//		*--vp = 0;
//	}*///方法1
//
//
//	//for (vp = &values[N_VALUES - 1]; vp >=&values[0]; vp--)
//	//{
//	//	*vp = 0;
//	//}//方法2
//
//   //注意：C语言标准规定，允许指向数组元素的指针与指向数组最后一个元素后面的那个内存
//	//比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较
//	//所以第二种方法不可行，虽然容易理解但是不符合标准。
//
//	return 0;
//}


//指针和数组
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;
//	//[ ]是一个操作符 2和arr是两个操作数
//	//a+b
//	//b+a
//	//编译器处理arr[2]时，是转换成*(arr+2)进行计算的
//	//所以此时p[2]也是和arr[2]相同的，因为p[2]在编译器处理时转换为了*(p+2)
//	printf("%d\n", arr[2]);
//	printf("%d\n", 2[arr]);
//	printf("%d\n", p[2]);
//	printf("%d\n", 2[p]);
//	printf("%d\n", *(p+2));
//	//arr[2] <==> *(p+2) <==> *(arr+2) <==> *(2+arr)
//	//所以：arr[2]<==>2[arr]
//	return 0;
//}
//注：三级指针都已经很少用到
//int main()
//{
//	int a = 10;
//	int* pa = &a;//pa是指针变量，一级指针
//	//ppa就是一个二级指针变量
//	int ** ppa=&pa;//pa也是变量，&pa取出pa在内存中起始地址
//	printf("%d\n", **ppa);
//	return 0;
//}
