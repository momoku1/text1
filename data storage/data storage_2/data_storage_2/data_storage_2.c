#define   _CRT_SECURE_NO_WARNINGS 1
//数据存储2
//总结：本章重点
//1.数据类型详细介绍
//2.整形在内存中存储：原码、反码、补码
//3.大小端字节序介绍及判断
//4.浮点型在内存中的存储解析



//浮点型在内存中的存储
//常见的浮点数：
//3.14159 1E10 浮点数家族包括：flaot、double、long double类型。浮点数表示的范围：
//在float.h中定义    整形家族：limits.h



/*浮点数存储举例*/
//例题1：
#include <stdio.h>
#include <limits.h>
int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);
	//9-----00000000000000000000000000001001
	//
	printf("*pFloat的值为：%f\n", *pFloat);//0.000000----如果将整数9按浮点数打印，那么第2位到第9位所代表的是指数，指数为0，那么最终
	//s-- 0 E----00000000 M----00000000000000000001001
	//E为全为0的情况，将数据前面直接加0.得0.00000000000000000001001*2^-126
	//无限接近于0，且超出浮点数保留位数，得出结果0
	*pFloat = 9.0;//以浮点数的视角，存储9.0
	//1001--->1.001*2^3--->0 10000010 00100000000000000000000 
	printf("num的值为：%d\n", n);//以整数的视角----01000001000100000000000000000000
   //对应十进制数：1091567616
	printf("*pFloat的值为：%f\n", *pFloat);//9.000000
	return 0;
}

//根据上述例子，可发现浮点数和整数在内存中的存储方式一定是有区别的
//整数存储是补码，在本编译器中是小端字节序的方式

//根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数v可以表示成下面的形式
//----(-1)^S*M*2^E
//----(-1)^S表示符号，当s=0，V为正数；当s=1，V为负数
//----M表示有效数字，大于等于1，小于2
//----2^E表示指数位

//浮点数：5.5-----十进制
//二进制：101.1---->科学计数法：1.011*2^2   ----->(-1)^0*1.011*2^2
																					//s=0 M=1.011 E=2
//IEEE 754规定：对于32位的浮点数，最高的1位是符号位s,接着的8位是指数E，剩下的23为有效数字M
//double:     最高位符号位，之后11位是指数位，后面所有位数是有效数字位


//规定M的值   1<=M<=2  表现为1.xxxxxx  所以在IEEE754规定，在计算机内部保存M时，默认这个数
//的第一位总是1，因此可以舍去，只保存后面xxxxxx部分。比如1.01，只保存01，等读取的时候，再把
//第一位1加上去。这样可以节省一位有效数字。

//至于指数E，情况就比较复杂
//首先，E为一个无符号整数，意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值
//范围为0~2047。但是，科学计数法中E是可以出现负数的，所以IEEE754规定，存入内存时E的真实值
//必须再加上一个中间数，对于8位的E,这个中间数是127；对于11位，中间数是1023。比如，2^10的E是
//所以保存成32浮点数时，必须保存成10+127=137，即10001001。
//结论有效数字位只保存了小数位，前面的1是默认的，读取的时候才加上
//int main()
//{
//	float f = 5.5f;
//	//101.1
//	//1.011*2^2
//	//s=0;M=1.1011 E=2
//	//s=0 M=011 E=2+127
//	//0 1000000 1 011 0000 0000 0000 0000 0000
//	//40 b0 00 00
//	return 0;
//}  

//然后指数E从内存中取出分为三种情况;
//1.E不全为0或不全为1
//这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值
//再将有效数字M前加上第一位的1。比如：0.5（1/2）的二进制形式为0.1，由于规定正数部
//部分必须为1，即将小数点右移1位，则为1.0*2^（-1），其阶码为-1+127=126，表示为
//011111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制
//表示形式为：0  01111110 00000000000000000000000
//2.E全为0//E=-127+127 ----原数相当于无限接近于0的数                                                                                                                                                                                                                         
//这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不在加上第一位的1
//而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字
//3.E全为1//E=128+127
//这时，如果有效数字M为全0，表示±无穷大（正负取决于符号位s）

//存进去 第一位符号位 接着8位指数E（且存入时需要加上127） 剩下23位是有效数字位(此位只存1.后面的小数位）
//取出来 第一位符号位 指数取出需要减去127 有效数字位取出需要加上1.
//分三种情况取出以上是既不是全1也不是全0的情况





