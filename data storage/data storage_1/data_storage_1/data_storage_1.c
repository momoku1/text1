#define   _CRT_SECURE_NO_WARNINGS 1
/*数据存储1*/
//#include <stdio.h>
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//
//
//	printf("%p\n", &i);
//	printf("%p\n",&arr[9]);
//	//debug版本i的地址的确比arr[9]的地址大
//	//release版本i的地址比arr[9]的地址小。
//	//for (i = 0; i <= 12; i++)
//	//{
//	//	arr[i] = 0;
//	//	printf("hehe\n");//死循环
//	//	//原理：i的地址刚好和arr[12]的地址重合（对应的同一个地址），所以当i=12的时候进入循环
//	//	//后，被arr[12]赋值为0,i的值也被修改为0。
//	//}
//	return 0;
//}
//越界访问
//i和arr是局部变量，存储在在栈区中
//栈内存   先使用高地址  ，再使用低地址。
//数组随着下标的增长，地址是由低到高变化的

//以上程序在release版本没有死循环，它会自我优化


//一、数据类型介绍
//内置类型：char ,short, int,  long, long long, float, double
//类型的意义：
//1.使用这个类型开辟内存空间的大小（大小决定了使用范围）
//2.如何看待内存空间的视角
//二、类型的基本归类：
//1.整形家族：
//char short  int  long
//各自都有无符号（unsigned）和有符号（signed）
//2.浮点型家族：
//float double
//3.构造类型-自定义类型
//结构体类型-struct
//数组
//枚举类型-----enum
//联合体-----union
//4.指针类型
//5.空类型
//void
//函数返回类型 void test();
//函数参数，指针
//指针 void *p


//1.整形在内存中的存储
//int main()
//{
//	int a = -10;
//	int b = 10;
//	return 0;
//}

//数据在内存中以二进制的形式存储
//对于整数来说：
//整数二进制形式：原码、反码、补码
//正整数：三者相同
//负整数：需要计算

//整数在内存中存储的是补码---倒序
//为什么存储补码？
//使用补码，可以将符号位和数值域统一处理；
//同时，加法和减法也可以统一处理（CPU只有加法器）
//此外，补码与原码相互转换，其运输过程是相同的
//不需要额外的硬件电路
//int main()
//{
//	//1-1
//	//1+(-1)
//	//00000000000000000000000000000001
//	//10000000000000000000000000000001
//	//10000000000000000000000000000010
//	//假如用原码计算，如上
//	//得到的结果：是-2
//
//	//00000000000000000000000000000001
//	//11111111111111111111111111111111
//	//100000000000000000000000000000000
//	//只能计算32位，所以最高位舍弃得：
//	//00000000000000000000000000000000
//	//-0结果正确
//
//	return 0;
//}

//大小端介绍
//什么是大端和小端
//大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中
//小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。
//为什么有大端和小端：
//在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节
//为8bit，但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型。另外
//对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节
//那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式

//大端字节序和小端字节序

//int main()
//{
//	int a = 0x11223344;
//	//地址是由低到高变换的----存储是低位到高位存储的
//	//所以当前编译器是小端存储---及小端字节序
//	return 0;
//}


////////////////////////////////////////////////
/*百度2015年系统工程师笔试题*/
//请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。
//大端字节序，数据的高位字节序存储在低位地址，低位字节序存储在高位地址
//小端字节序，数据的高位字节序存储在高位地址，低位字节序存储在低位地址
/*写代码判断当前机器的字节序*/
//#include <stdio.h>
//int main()
//{
//	int a = 0x00000001;
//	char* p = (char*)&a;//指针的大小只取决于地址线的多少，32位---4字节
//	if (*p == 0)//指针的类型决定了访问权限的多少--char型指针只能访问一个字节
//		printf("小端字节序\n");
//	else
//		printf("大端字节序\n");
//	return 0;//
//}


//例题1
//输出结果是什么？
//#include <stdio.h>
//int main()
//{
//	char a = -1;//整数存储到char会发生截断，只存储低8位
//	signed char b = -1;//-128~127
//	unsigned char c = -1;//无符号-0~255
//	//在内存中存储-----1111111111---255-----00000000000000000000000011111111
//	//此时的1不代表符号值
//	printf("a=%d,b=%d,c=%d", a, b, c);//整形提升会按照符号位来提升
//	return 0;
//}

//补充：C语言标准没有规定char到底是signed还是unsigned
//取决于编译器，visual studio是将char规定为了signed
//而int在C语言标准中规定了是signed int
//short 是signed short

//例题2：
//下面程序输出什么？
//#include <stdio.h>
//int main()
//{
//	char a = -128;//有符号-----10000000-----存储截断后的结果
//
//	//整形提升-----11111111111111111111111110000000
//	printf("%u\n", a);//打印无符号整形---将上述整形提升的结果按正数打印
//	//正整数原码和补码相同所以直接打印该数值
//	//结果：4294967168
//	return 0;
//}

//例题3
//#include <stdio.h>
//int main()
//{
//	char a = 128;//存储截断后的结果-----10000000----表示的-128
//	//整形提升-----11111111111111111111111110000000----
//	printf("%u\n",a);//和例题2结果相同--因为截断后的值相同
//	return 0;
//}

//例题4
//#include <stdio.h>
//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	return 0;
//}

//例题5
//#include <stdio.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)//i=0时，补码00000000000000000000000000000000
//	{									    //1的补码00000000000000000000000000000001
//											//相减      11111111111111111111111111111111
//		printf("%u\n", i);//9,8,7,6,5,4,3,2,1,0之后打印的无符号数----所以是2^32-1-----4,294,967,295
//	}
//	return 0;
//}

//例题6
//#include <stdio.h>
//#include <string.h>
//int main()
//{
//	char a[1000] ;
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//i=128之后-129--截断后存储结果---100...10000001
//																	//反码：---111...01111110
//																	//补码：---111...01111111
//																	//截断：---01111111------127
//	//												当i=254  -255-----100...11111111-补码：111...00000001截断：01111111
//	//												当i=255  -256-----100...100000000-补码：111...100000000截断：00000000
//	//												所以当arr[255]存储的就是0
//	}
//	printf("%d", strlen(a));//遇见0及'\0',时结束
//	return 0;
//}

//#include <stdio.h>
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)//当i=255 之后再加1 ------00..100000000---截断00000000 又变回了0 
//	{//也可以理解为unsigned char取值范围在0~255，而循环的条件将i的所有值都包含了，肯定死循环
//		printf("hello world\n");
//	}
//	return 0;
//}




